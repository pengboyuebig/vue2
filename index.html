<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>test_unit</title>
  </head>
  <body>
    <div id="app">

    </div>
    <!-- <input type="search">
    <input type="datetime" name="" id="">
    <input type="tel" name="" id="">
    <input type="number" name="" id=""> -->
    <!-- built files will be auto injected -->
    <script>
    //   let Foo = () => {
    //   console.log('foo', this)
    // }
    // console.log(Foo.prototype, 'foo.prototype')
    // let f = new Foo()
    // console.log(f)
    // const foo = ''
    // const result1 = foo || '默认值'
    // const result2 = foo ?? '默认值'
    // console.log(result1,12, result2,typeof result2,12)

    // const bigInt = 9007199254740991n
    // console.log(bigInt + 1n, bigInt + 2n)
    
    // 逻辑运算符
    // let message = ''
    // message ||='Hellow World'
    // console.log(message)
    // let obj = {
    //   name:'why'
    // }
    // obj &&= obj.name
    // console.log(obj)
    // let foo = ''
    // foo ??='默认值'
    // console.log(foo)
    //console.log(a=3)
    // 'use strict'
    // console.log(this)
    // function foo () {
    //   console.log(this)
    // }
    // var obj1 = {
    //   name: 'obj1',
    //   foo: foo
    // }
    // var obj2 = {
    //   name: 'obj2'
    // }
    // obj1.foo();
    // // 这个可以这么理解，当上一行代码执行了以后，其会向全局暴露出来所以下面执行了以后this就是变成了window了
    // (obj2.foo = obj1.foo)()
// console.log(Object({name:'adas'}),{name:'adas'})
    /* Function.prototype.hyapply = function(thisBings,args){
      thisBings = thisBings?Object(thisBings):window
      thisBings.fn = this
      if(!args){
        thisBings.fn()
      }else{
        var result = thisBings.fn(...args)
      }
      delete thisBings.fn
      return result
    }
    Function.prototype.hycall = function(thisBings,...args){
      thisBings = thisBings? Object(thisBings):window
      thisBings.fn = this
      var result = thisBings.fn(...args)
      delete thisBings.fn
      return result
    }
    Function.prototype.hybind = function(thisBings,bindArgs){
      thisBings = thisBings?Object(thisBings):window
      thisBings.fn = this
      return function(...newArgs){
        var args = [...bindArgs,...newArgs]
        return thisBings.fn(...args)
      }
    } */

    /* let obj = new Object()
    let obj2 = {
      name:'伟健',
      age:29
    }
    let obj3 = Object.create(obj2)
    console.log(obj,obj2,obj3) */


    // let a={
    //   name:10,
    //   age:'one'
    // }
    // let c = Object.entries(a)
    // c[0][0]='peng'
    // console.log(c)
    // console.log(Object.fromEntries(c))

    // let obj1 = {
    //   name:'peng',
    //   age:23,
    //   friend:'li'
    // }
    // let obj2 = Object.create(obj1)
    //  //obj2.prototype.constructor = {}
    // console.log(obj1,obj2,obj2['Prototype'])

    //只有构造函数才会有隐式原型和现实原型
    // function AA(){

    // }
    // let aa = new AA()
    // let a = {}
    // console.log(aa , AA,aa.__proto__,aa.prototype,AA.__proto__,AA.prototype)
    // console.log(a.__proto__,a.prototype)

    // let a='qwertyuiop'
    // console.log(a.padStart(15,'1'))
    // console.log(a.padEnd(15,'1'))

    // let a = '   dasd  '
    // console.log(a.trimStart())
    // console.log(a.trimEnd())
//     let obj1 = {
//       name:'peng'
//     }
//     let obj2={
//       name:'peng'
//     }
// console.log(Object.is(obj1.name,obj2.name))

// 原型链的理解
// function Person(name){
//   this.name =  name || 'why'
// }
// Person['prototype'].running = function(){
//   console.log(this.name+'running')
// }
// function Student(name,friends,sno){
//   Person.call(this,name,friends)
//   this.sno = sno
// }
// let s = new Student(1,2,3)
// let p = new Person()
// console.log(p , 'new person')
// // let p = new Person()
// // Student.prototype = p
// // Student.prototype.studying = function(){
// //   console.log(this.name + 'studying')
// // }
// console.dir(Person)
// console.dir(Student)
// console.dir(s)
// console.log(typeof s)

/* class Person{
  constructor(name , age , height){
    this.name = name
    this.age = age
    this.height = height
  }
  running(){
    console.log(this.name , 'running___')
  }
  eating(){
    console.log(this.name , 'eating')
  }
  set p(newName){
    console.log('set,p')
    this._name = newName
  }
  get p(){
    console.log('get,p')
    return this._name
  }
  static create(){
    return new Person(12313123)
  }
}
class Student extends Person {
  constructor(name,age){
    super(name,age)
  }
}
let p = new Person()
let s = new Student('peng',18)
console.dir(Person)
console.dir(Student) */

// let obj={
//   name:'peng',
//   age:24
// }
// let sex = '啊实打实'
// let height = 11231
// Object.defineProperties(obj,{
//   sex:{
//     get(a){
//       console.log(a,'adasd')
//       return sex
//     },
//     set(value){
//       console.log('sex',value)
//       sex=value
//     }
//   },
//   height:{
//     get(){
//       return height
//     },
//     set(value){
//       console.log('height',value)
//       height = value
//     }
//   }
// })
      // let obj = {
      //   name:'张三',
      //   age:28
      // }
      // const o = new Proxy(obj,{
      //   get(a , b,c){
      //     console.log(a,b,c)
      //     return Reflect.get(a,b)
      //   },
      //   set(a,b,c){
      //     console.log(a,b,c)
      //     Reflect.set(a,b,c)
      //   },
      //   deleteProperty(a,b,c){
      //     console.log(a,b,c)
      //     Reflect.deleteProperty(a,b)
      //   }
      // })

      // let a = /aasd/g
      // let c = 'aasdqwewqeqeqweaasd'
      // console.log(a.test(c))
      // console.log(c.match(a))
      // console.log(a.exec(c))
      // console.log(a.exec(c))

      // function Student(name , age){
      //   this.name = name
      //   this.age = age
      // }
      // function Animal(){

      // }
      // const stu = Reflect.construct(Student,['why',16],Animal)
      // console.log(stu.__proto__===Animal.prototype)

//       function OneClass() {
//     this.name = 'one';
// }

// function OtherClass() {
//     this.name = 'other';
// }

// // 创建一个对象:
// var obj1 = Reflect.construct(OneClass, [1,2], OtherClass);

// // 与上述方法等效:
// var obj2 = Object.create(OtherClass.prototype);
// OneClass.apply(obj2, [1,2]);

// console.log(obj1.name); // 'one'
// console.log(obj2.name); // 'one'

// console.log(obj1 instanceof OneClass); // false
// console.log(obj2 instanceof OneClass); // false

// console.log(obj1 instanceof OtherClass); // true
// console.log(obj2 instanceof OtherClass); // true

// console.log('-----------------------')
// class A {
//   constructor() {
//     console.log(new.target.name);
//   }
// }
// class B extends A { constructor() { super(); } }

// var a = new A(); // logs "A"
// var b = new B(); // logs "B"

// class C { constructor() { console.dir(new.target); } }
// class D extends C { constructor() { super(); } }

// var c = new C(); // logs class C{constructor(){console.log(new.target);}}
// var d = new D(); // logs class D extends C{constructor(){super();}}

// function AA(){
//   console.dir(new.target)
// }
// AA()
// let a = new AA()

// new Promise((resolve,reject)=>{
//   console.log(1111111111)
// reject('a')
// }).then((resolve)=>{
//   //console.log(resolve)
//   console.log(resolve)
//   //resolve(111)
//   return 'saddsa'
// },reject=>{
//   console.log(reject,'reject')
//   return '彭伯曰'
// }).then((resolve)=>{
//   console.log(resolve)
//   console.log('resolve,reject',resolve)
//   //resolve(111)
//   return 'saddsa'
// }).catch(err=>{
//   console.log('err1',err)
// }).catch(err=>{
//   console.log('err2',err)
// })
// console.log(a)
// a.then((resolve,reject)=>{
//   console.log(resolve)
//   resolve(111)
// })
    </script>
  </body>
</html>
